# Завдання 1: Built-in область видимості (демонстрація використання вбудованих функцій та їх перекриття локальними функціями).

# 1.	Написати функцію my_sum, яка перекриває вбудовану функцію sum. Функція поинна просто виводити повідомлення: "This is my custom sum function!".

# 2.	Створити список чисел і викликати вбудовану функцію sum, щоб підсумувати значення списку.

# 3.	Викликати свою функцію my_sum, а потім ще раз спробувати скористатися вбудованою функцією sum.

# Питання для закріплення:

# •	Що відбувається, коли локальна функція має те саме ім'я, що й вбудована? Вона перекривається, якщо ми вже визивали нашу функцію з таким ім'ям

# •	Як можна отримати доступ до вбудованої функції, навіть якщо вона перекрита? За допомогою __builtins__.
# ____________________________________________________________________________________________________________________________________________________

# def my_sum():
#     print("This is my custom sum function!")

#     numbers = [10, 52, 33, 48, 54]

#     print("sum: ", sum(numbers))
    
# my_sum()

# ____________________________________________________________________________________________________________________________________________________
# Створити програму, яка імітує менеджер підписки на розсилку, демонструючи роботу з локальними, глобальними та вкладеними областями видимості.

# 1.	На глобальному рівні створити змінну subscribers = [] — це список для збереження імен підписників.

# 2.	Створити функцію subscribe, яка приймає ім'я підписника як аргумент і додає його до списку підписників.

# 3.	В середині функції subscribe створити вкладену функцію confirm_subscription, яка повертає повідомлення: "Підписка підтверджена для <ім'я>".

# 4.	Створити функцію unsubscribe, яка приймає ім'я та видаляє його зі списку підписників. Якщо таке ім'я не знайдено, повертає відповідне повідомлення.

# 5.	Використати програму для додавання кількох підписників, підтвердження підписки та відписки.

# ____________________________________________________________________________________________________________________________________________________

# subscribers = []

# def subscribe(name):
#     if name not in subscribers:
#         subscribers.append(name)
#         def confirm_subscription(name):
#             print(f"Підписка підтверджена для {name}")
#     else:
#         print(f"{name} вже є у списку підписників.")

# def unsubscribe(name):
#     if name in subscribers:
#         subscribers.remove(name)
#         return f"{name} успішно відписаний"
#     else:
#         return f"Підписник з ім'ям {name} не знайдений"

# subscribe("Stas")
# subscribe("Taras")
# subscribe("Stas")

# print(subscribers)  

# print(unsubscribe("Stas"))  

# print(subscribers)  

# ____________________________________________________________________________________________________________________________________________________

# Завдання 3: Магазин замовлень з акційними знижками

# Написати програму, яка імітує систему замовлення з акціями, де знижки зберігаються у глобальній області, а нарахування знижки відбувається локально для кожного клієнта.

# 1.	Створити глобальну змінну discount = 0.1 (10% знижка).

# 2.	Створити функцію create_order, яка приймає ціну товару як аргумент і всередині:

# o	обчислює кінцеву ціну з урахуванням знижки, що визначена глобальною.

# o	створює вкладену функцію apply_additional_discount, яка додає додаткову знижку (наприклад, для VIP-клієнтів) і змінює фінальну ціну.

# 3.	Використати ключове слово nonlocal, щоб функція могла змінювати кінцеву ціну у вкладеній області видимості.

# 4.	Після застосування всіх знижок вивести фінальну ціну.

# ____________________________________________________________________________________________________________________________________________________

# discount = 0.1  

# def create_order(price):
#     final_price = price - (price * discount)
#     print(f"Початкова ціна: {price}, кінцева ціна зі знижкою {discount*100}%: {final_price}")
    
#     def apply_additional_discount():
#         nonlocal final_price
#         additional_discount = 0.2
#         final_price -= final_price * additional_discount
#         print(f"Додаткова знижка {additional_discount*100}%, ціна зі знижкою: {final_price}")

#     apply_additional_discount()
    
#     print(f"Фінальна ціна після всіх знижок: {final_price}")

# create_order(1000) 

# ____________________________________________________________________________________________________________________________________________________

# Завдання 4: Таймер для тренування

# Розробити програму, яка симулює таймер для тренувань із вбудованою функцією, що дозволяє змінювати час тренування на кожному кроці.

# 1.	Створити глобальну змінну default_time = 60, яка задає стандартний час на кожне тренування (у хвилинах).

# 2.	Створити функцію training_session, яка:

# o	приймає кількість раундів тренування.

# o	використовує змінну time_per_round, що відповідає за час на раунд, і локально змінює її для кожного тренування.

# o	в середині функції створити вкладену функцію adjust_time, яка дозволяє налаштовувати час для кожного окремого раунду (через неявне використання nonlocal).

# 3.	Програма повинна виводити тривалість кожного раунду тренування.

# ____________________________________________________________________________________________________________________________________________________

# default_time = 60  

# def training_session(rounds):
#     time_per_round = default_time
    
#     def adjust_time(adjustment):
#         nonlocal time_per_round
#         time_per_round += adjustment
    
#     for i in range(1, rounds + 1):
#         print(f"Раунд {i}: {time_per_round} хвилин")
        
#         adjust_time(-5) 

# training_session(8)

# ____________________________________________________________________________________________________________________________________________________

# Завдання 5: Календар подій

# Розробити простий календар подій.

# 1.	Використовуючи замикання, створити функції для додавання подій, видалення подій та перегляду майбутніх подій.

# 2.	Зберігати події у списку за допомогою глобальної змінної.

# ____________________________________________________________________________________________________________________________________________________

# event_list = []

# def event_calendar():

#     def add_event(event):

#         event_list.append(event)
#         print(f"Подію '{event}' додано.")
    
#     def remove_event(event):

#         if event in event_list:
#             event_list.remove(event)
#             print(f"Подію '{event}' видалено.")
#         else:
#             print(f"Подію '{event}' не знайдено.")
    
#     def view_events():

#         if event_list:
#             print("Майбутні події:")
#             for event in event_list:
#                 print(f"- {event}")
#         else:
#             print("Немає майбутніх подій.")
    

#     return add_event, remove_event, view_events

# add_event, remove_event, view_events = event_calendar()


# add_event("Тренування")
# add_event("Заняття по Python Pro")
# add_event("Зустріч з друзями")
# view_events()
# remove_event("Зустріч з друзями")
# view_events()

# ____________________________________________________________________________________________________________________________________________________

# Завдання 6: Калькулятор з використанням замикань

# Створити калькулятор, який використовує замикання для створення функцій додавання, віднімання, множення та ділення.

# 1.	Написати функцію create_calculator, яка приймає оператор (наприклад, '+', '-', '*', '/') та повертає функцію для виконання обчислень.

# 2.	Використати цю функцію, щоб створити калькулятор для кількох операцій, і протестувати його.

# ____________________________________________________________________________________________________________________________________________________

# def create_calculator(operator):

#     def add(a, b):
#         return a + b
    
#     def subtract(a, b):
#         return a - b
    
#     def multiply(a, b):
#         return a * b
    
#     def divide(a, b):
#         if b == 0:
#             return "Помилка: ділення на нуль!"
#         return a / b
    
#     if operator == '+':
#         return add
#     elif operator == '-':
#         return subtract
#     elif operator == '*':
#         return multiply
#     elif operator == '/':
#         return divide
#     else:
#         raise ValueError("Невідомий оператор! Використовуйте '+', '-', '*', '/'.")

# add = create_calculator('+')
# subtract = create_calculator('-')
# multiply = create_calculator('*')
# divide = create_calculator('/')

# print("Додавання 10 + 5 =", add(10, 5))
# print("Віднімання 10 - 5 =", subtract(10, 5))
# print("Множення 10 * 5 =", multiply(10, 5))
# print("Ділення 10 / 5 =", divide(10, 5))
# print("Ділення 10 / 0 =", divide(10, 0))  

# ____________________________________________________________________________________________________________________________________________________

# Завдання 7: Трекер витрат

# Розробити програму для трекінгу витрат, яка використовує глобальні змінні для зберігання загальної суми витрат.

# 1.	Створити глобальну змінну total_expense і функцію add_expense, яка приймає суму витрат і додає її до загальної суми.

# 2.	Додати функцію get_expense, яка повертає загальну суму витрат.

# 3.	Створити інтерфейс (консольний), щоб користувач міг додавати витрати і переглядати загальну суму.

# ____________________________________________________________________________________________________________________________________________________

# total_expense = 0.0

# def add_expense(amount):

#     global total_expense
#     total_expense += amount
#     print(f"Витрати {amount:.2f} внесено. Загальна сума витрат: {total_expense:.2f}")

# def get_expense():

#     return total_expense

# def main():

#     while True:
#         print("\nМеню:")
#         print("1. Додати витрати")
#         print("2. Переглянути загальну суму витрат")
#         print("3. Вийти")
        
#         choice = input("Виберіть опцію (1, 2 або 3): ")
        
#         if choice == '1':
#             try:
#                 amount = float(input("Введіть суму витрат: "))
#                 add_expense(amount)
#             except ValueError:
#                 print("Помилка: введіть дійсне число.")
        
#         elif choice == '2':
#             print(f"Загальна сума витрат: {get_expense():.2f}")
        
#         elif choice == '3':
#             print("Вихід.")
#             break
        
#         else:
#             print("Невірний вибір. Спробуйте ще раз.")

# if __name__ == "__main__":
#     main()

# ____________________________________________________________________________________________________________________________________________________

# Завдання 8: Зберігання налаштувань користувача

# Реалізувати систему зберігання налаштувань користувача за допомогою замикань.

# 1.	Створити функцію create_user_settings, яка повертає функцію для зберігання і отримання налаштувань.

# 2.	Налаштування можуть включати такі параметри, як theme, language і notifications.

# 3.	Додати можливість зберігати, змінювати та переглядати налаштування.

# ____________________________________________________________________________________________________________________________________________________

# def create_user_settings():
#     settings = {
#         "theme": "light",       
#         "language": "English",  
#         "notifications": True   
#     }
    
#     def user_settings(action, key=None, value=None):
#         if action == "view":
#             if key:
#                 return settings.get(key, "Налаштування не знайдено")
#             return settings 
#         elif action == "set" and key and value is not None:
#             settings[key] = value
#             print(f"Налаштування '{key}' змінено на '{value}'")
#         else:
#             print("Недостатньо параметрів")
    
#     return user_settings

# if __name__ == "__main__":
#     user1_settings = create_user_settings()

#     print("Налаштування користувача 1 за замовчуванням:")
#     print(user1_settings("view"))

#     user1_settings("set", "theme", "dark")
#     user1_settings("set", "language", "Ukrainian")

#     print("\n Тема користувача 1:")
#     print(user1_settings("view", "theme"))

#     print("\n Оновлені налаштування користувача 1:")
#     print(user1_settings("view"))

# ____________________________________________________________________________________________________________________________________________________

# Завдання 9: Кешування результатів функції

# Написати програму для кешування результатів функції, щоб покращити продуктивність.

# 1.	Створити функцію memoize, яка приймає функцію та повертає нову функцію, що зберігає результати викликів.

# 2.	Використати цю функцію, щоб кешувати результати обчислень (наприклад, факторіал або фібоначі).

# ____________________________________________________________________________________________________________________________________________________

# def memoize(func):
#     cache = {}  

#     def memoized_func(n):  
#         if n in cache:
#             return cache[n]  
#         result = func(n) 
#         cache[n] = result  
#         return result
    
#     return memoized_func

# @memoize
# def factorial(n):
#     if n == 0 or n == 1:
#         return 1
#     return n * factorial(n - 1)

# @memoize
# def fibonacci(n):
#     if n == 0:
#         return 0
#     elif n == 1:
#         return 1
#     return fibonacci(n - 1) + fibonacci(n - 2)

# if __name__ == "__main__":
#     print("Факторіал 5:", factorial(5))   
#     print("Факторіал 10:", factorial(10)) 

#     print("\n Числа Фібоначчі:")
#     for i in range(10):
#         print(f"fibonacci({i}) =", fibonacci(i))
# ____________________________________________________________________________________________________________________________________________________

# Завдання 10: Створення товарів для онлайн-магазину

# Розробити програму для управління товарами в онлайн-магазині, використовучи карирувані функції.

# 1.	Написати функцію create_product, яка приймає назву, ціну та кількість товару.

# 2.	Використати замикання для створення функції, яка дозволяє змінювати ціну товару.
# ____________________________________________________________________________________________________________________________________________________

def create_product(name, price, quantity):

    def change_price(new_price):
        nonlocal price  
        price = new_price
        print(f"Ціну товару '{name}' змінено на {price:.2f}")

    def product_info():
        return f"Товар: {name}, Ціна: {price:.2f}, Кількість: {quantity}"

    return change_price, product_info

if __name__ == "__main__":
    change_price, product_info = create_product("Смартфон", 1500.00, 10)

    print(product_info()) 

    change_price(1350.00)

    print(product_info())  
# ____________________________________________________________________________________________________________________________________________________